ğŸ”· 1ï¸âƒ£ What We Actually Built (System Overview)

You built a real-time distributed event control system.

It consists of:

Frontend (Browser)
â¬‡
WebSocket connection (Socket.IO)
â¬‡
Node.js server (Express)
â¬‡
Redis (persistent storage)
â¬‡
Deployed on Render (cloud hosting)

It is NOT just a timer.
It is a synchronized control system.

ğŸ”· 2ï¸âƒ£ Why We Used Each Technology
ğŸŸ¢ 1. Node.js + Express

What it does:

Runs backend server

Serves your HTML, CSS, JS

Manages real-time events

Controls logic

Why we used it:
Because we needed:

Real-time control

WebSocket support

Centralized authority server

Express handles HTTP routes.
Socket.IO handles real-time communication.

ğŸŸ¢ 2. Socket.IO (Real-time Sync Engine)

This is the core of your system.

Without Socket.IO:

Each screen would run its own timer

They would drift apart

No synchronized video control

Socket.IO allows:

Server pushes state to ALL connected devices instantly

Admin actions broadcast to every screen

Example:
You press â€œVâ€ â†’ server receives â†’ server emits â†’ all projectors switch video instantly.

This is distributed event control.

ğŸŸ¢ 3. Redis (Why We Used It)

This is important for presentation.

Redis is NOT used as a traditional database here.

We used Redis to store:

eventStart timestamp

Why?

Because cloud platforms like Render:

Restart containers

Go to sleep

Lose memory

Kill RAM state

If we only stored startTime in memory:

Server restarts â†’ timer resets â†’ disaster.

Redis solves this by storing startTime outside server memory.

Even if:

Render restarts

Server crashes

One device disconnects

Timer continues correctly.

Redis = persistent distributed memory.

ğŸŸ¢ 4. Render (Deployment Platform)

Render does:

Hosts your Node.js server on the internet

Gives public URL

Keeps server running

But free tier:

Goes to sleep when idle

Restarts container

That is why Redis was mandatory.

Render = execution environment
Redis = persistent state layer

ğŸŸ¢ 5. Why Timer Works Even If Laptop Sleeps

When laptop sleeps:

Frontend stops rendering

Clock freezes visually

When it wakes:

Browser reconnects

Socket emits forceSync

Server sends correct state

Client recalculates remaining time using server startTime

So timer is never client-based.
It is server-time authoritative.

This is critical.

ğŸ”· 3ï¸âƒ£ Architecture Flow (Explain Like This)
Step 1 â€” Admin presses Shift + R

â¬‡
Server sets:

startTime = Date.now()

â¬‡
Server stores startTime in Redis

â¬‡
Server emits sync state to all clients

â¬‡
All screens calculate:

remaining = DURATION - (now - startTime)

â¬‡
Everyone displays same countdown.

ğŸ”· 4ï¸âƒ£ Why We Used Redis Instead of MongoDB

Good question for presentation.

MongoDB is for structured data.

We only needed:

One timestamp

Ultra-fast read/write

Low overhead

No schema

Redis is:

In-memory key-value store

Extremely fast

Perfect for time-sensitive systems

Redis is ideal for:

Session management

Counters

Distributed timers

This is correct engineering choice.

ğŸ”· 5ï¸âƒ£ Why We Didnâ€™t Use Local Storage

If we used browser localStorage:

Each device would have different time

No synchronization

No central control

Admin actions wouldnâ€™t propagate

So localStorage = wrong design.

ğŸ”· 6ï¸âƒ£ What Makes This â€œEngineeringâ€

This is not a static timer.

It includes:

âœ” Distributed state synchronization
âœ” Fault tolerance (restart safe)
âœ” Live admin command broadcasting
âœ” Dynamic media control
âœ” Cloud deployment
âœ” Real-time system recovery

That is backend system design.

ğŸ”· 7ï¸âƒ£ If Someone Asks: â€œWhat Happens If Render Restarts?â€

Answer confidently:

Server memory clears

But startTime is stored in Redis

On boot, server reads Redis

Clients reconnect

Timer continues from correct value

Zero loss.

ğŸ”· 8ï¸âƒ£ If Someone Asks: â€œHow Is Time Drift Prevented?â€

Timer does NOT count locally from 31 hours.

Instead:

remaining = DURATION - (currentTime - startTime)

So drift is mathematically impossible as long as system clocks are correct.

ğŸ”· 9ï¸âƒ£ Final Architecture Summary (Use This In Presentation)

We designed a cloud-hosted, Redis-backed, real-time synchronized event control system using Node.js, Express, and Socket.IO. The system ensures distributed countdown consistency, persistent state management, and instant media control across multiple display clients.



"""

<!-- https://krk-fest-timer.onrender.com -->
<!-- https://krk-fest-timer.onrender.com/?admin=fest123 -->